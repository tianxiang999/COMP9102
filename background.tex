\section{Background}
\subsection{SGX Overview}
\subsubsection{Secure Enclave}
A secure enclave is a set of software and hardware features that together provide an isolated execution environment to enable a set of strong security guarantees for applications running inside the enclave. Enclave allows user-level as well as Operating System~(OS) code to define private regions of memory, whose contents are protected and unable to be either read or saved by any process outside the enclave itself, including processes running at higher privilege levels~\cite{}. 

%Primally, secure enclaves can provide confidentiality, integrity, and attestation. Confidentiality guarantees that an adversary outside of the enclave cannot inspect the state of execution inside the enclave, even if they compromise the operating system or correctness of the computation running inside the enclave even if the operating system has been compromised or a user attempts to subvert the execution of the program inside the enclave. Finally, hardware-based attestation provides an unforgeable proof that enables a remote party to verify what has run inside the enclave even if they donâ€™t have physical access to the machine. A secure enclave thus provides a powerful cornerstone for secure computing and development of secure systems in general. 


Intuitively, secure enclave fundamentally ensures the correctness and isolation in executing given process. The confirmation of input data freshness is hard to achieve, especially when the enclave encounters crash or restart. There are several wildly used secure enclave services~\cite{}, one of the most popular security architectures is Intel Software Guard Extensions (SGX)~\cite{}. However, a mature secure enclave designation as SGX still shows unsatisfied performance towards rollback attacks. In this report, we focus on the SGX architecture and its existing promotions in proposing protection against rollback attacks.

\subsubsection{SGX Architecture}
In a standard SGX as specified in~\cite{}, apart from the confidentiality and integrity nature of SGX, there are fundamentally three operations we concern in this report, \textit{i.e.}, the enclave creation, the sealing, and the attestation.
\begin{itemize}
	
	\item \textbf{Enclave creation.}  An enclave is created by the user client. In enclave creation, the client specifies the code to be processed in SGX. Security mechanisms in the processors create a data structure called SGX Enclave Control Structure (SECS) that is stored in a protected memory area. Enclaves' code created by the client cannot contain sensitive data. The start of the enclave is recorded by the processor, reflecting the content of the enclave code as well as the loading a sequence of instructions. The recording of an enclave start is called measurement and it can be used for later attestation. Once an enclave is no longer needed, the OS can terminate it and thus erase its memory structure from the protected memory.
	\item \textbf{Sealing} Enclaves can save confidential data across executions. Sealing is the process to encrypt and authenticate enclave data for persistent storage~\cite{}. All local persistent storage (\textit{e.g.} disk) is controlled by the untrusted OS. For each enclave, the SGX architecture provides a sealing key that is private to the executing platform and the enclave. The sealing key is derived from a Fuse Key (unique to the platform, not known to Intel) and an Identity Key that can be either the Enclave Identity or Signing Identity. The Enclave Identity is a cryptographic hash of the enclave measurement and uniquely identifies the enclave. If data is sealed with Enclave Identity, it is only available to this particular enclave version. The Signing Identity is provided by an authority that signs the enclave prior to its distribution. Data sealed with Signing Identity can be shared among all enclave versions that have been signed with the same Signing Identity.

	\item \textbf{Attestation} Attestation is the process of verifying that certain enclave code has been properly initialized. In local attestation a prover enclave can request a statement that contains measurements of its initialization sequence, enclave code and the issuer key. Another enclave on the same platform can verify this statement using a shared key created by the processor. In remote attestation the verifier may reside on another platform. A system service called Quoting Enclave signs the local attestation statement for remote verification. The verifier checks the attestation signature with the help of an online attestation service that is run by Intel. Each verifier must obtain a key from Intel to authenticate to the attestation service. The signing key used by the Quoting Enclave is based on a group signature scheme called EPID (Enhanced Privacy ID) which supports two modes of attestation: fully anonymous and linkable attestation using pseudonyms~\cite{}. The pseudonyms remain invariant across reboot cycles (for the same verifier). Once an enclave has been attested, the verifier can establish a secure channel to it using an authenticated key exchange mechanism.

\end{itemize}

In this report, protocols described in Section~\ref{solutions} primally utilize these three operations in SGX to provide rollback attack protections.

\subsubsection{SGX Counter}

Intel has recently added support for monotonic counters~(MC)~\cite{} as an optional SGX feature. The Monotonic Counter can be utilized by enclave developers for rollback attack protection. 

SGX supports creating a limited number of MCs for each enclave. Monotonic counters are shared among enclaves that have the same code. An enclave can query availability of counters from the Platform Service Enclave (PSE). If supported, the enclave can create up to 256 counters. The default owner policy encompasses that only enclaves with the same signing key may access the counter. Counter creation operation returns an identifier that is a combination of the Counter ID and a nonce to distinguish counters created by different entities. On creating a MC, it gets written to the non-volatile memory in the platform. The enclave must store the counter identifier to access it later, as there is no API call to list existing counters. After a successful counter creation, an enclave can increment, read, and delete the counter. Because each enclave shares the same value of the monotonic counters, it guarantees the verification for data freshness. In other words, only when an enclave preserves the same counter value as the others in the platform, its reserving data are the latest. Also, when one enclave encounters crash or reboot, it can recover data with the help of monotonic counters shared in the platform. 

According to the SGX API documentation~\cite{}, counter operations involve writing to a non-volatile memory. Repeated write operations can cause the memory to wear out, and thus the counter increment operations may be rate limited. 


\subsection{Rollback Attack}

Rollback attacks remain a potential secure problem in secure enclave. In a rollback attack, attackers replace the latest data with an older version without being identified by the system. 

Data integrity violation through rollback attacks can have severe implications. Consider, for example, a financial application implemented as an enclave. The enclave repeatedly processes incoming transactions at high speed and maintains an account balance for each user or a history of all transactions in the system. If the adversary manages to revert the enclave to its previous state, the maintained account balance or the queried transaction history does not match the executed transactions.

In reality, enclaves cannot easily detect this replay, because the processor is unable to maintain persistent state across enclave executions that may include reboots or crash. Another way to carry out rollback attacks in secure enclaves is to create multiple instances of a same process and route update requests to one instance and read requests to the other. Due to the characteristic of secure enclave, the instances are indistinguishable to remote clients or OS.

To avoid rollback attacks, most commonly considered direction is to record the time related information for every state change. In this paper, we mainly discuss three designations in rollback attacks protection built on the SGX architecture. The goal of methods specified in Section~\ref{solutions} are to guarantee the data integrity, confidentiality, and freshness towards rollback attacks based on SGX architecture. Note that for different methods, different level of adversary's strength is considered, which is listed and compared in Section~\ref{solutions}.

